# theoryforjava
Оглавление:
1. Java core
   1.1
   1.2 Паттерны проектирования
3. Spring
   2.1 Qualifier
   2.2
   2.3
4. Полезные ссылки, паттерны, инструменты и т.д.
   2.1
   2.2
   
1. **Java core**
   **Паттерн Синглтон**
   
   
3. **Spring**  
https://www.youtube.com/watch?v=l20USjGgnTo  
  Главная идея Inversion Of Control (инверсия контроля) в том, что разрабточки больше не отвечает за создание объектов. Он лишь предаставляет фреймворку минимум информации (конфигурации), а спринг полагаясь на эту информацию сам иницилизирует классы, создаст нужные объекты, внедрит нужные зависимости в эти объекты и т.д. Inversion Of Control (IoC) - это всего лишь принцип, концептуальное описание. Реализацицей может быть множество. В Spring - реализацией IoC является Dependency injection (а конкретно Spring Conteiner, это уже более детальная реализация воплащена в Sring Framework). Dependency injection говорит о том, что разработчик не участвует в процессе инициализации классов, внедрения зависимости, в процессе конфигурации зависимостей, он только делает описательный характер. Разработчик описывает лишь то, каким он хочет видеть объект, а как он станет таким - его не беспокоит. Мы его заберем, когда он будет готов. Spring (Dependency injetion) занимается ready to use - полностью сконфигурированная систама готова к использованию. (Не надо нам звонить, мы сами вам позвоним - не думай о классах пока они тебе не нужны, когда они будут тебе нужны мы тебе сами всё сконфигурируем и направим). Вот чем занимается DI и вот в частности занимается Spring Conteiner, который является частной реализацией принципа IoC, выраженной в реализации DI.  
  Как это работает? IoC - принцип, DI - реализация. SpringConteiner или же SpringContext - в нашем случае одно и то же. Как гласит документация - правильно SpringIoCConteiner. Но чаще всего, разработчики его просто называют контекст. Контекст - наш контейнер, в котором хранятся наши объекты, где они собираются, где они живут и откуда мы их получаем.  
  По своей сути, спринг контейнер и есть фабрика, которая собирает объекты, только еще кладет их в контейнер. Немаловажно то, что интерфейс ApplicationContext -> наследуется от BeanFactory
  Хорошая картинка представлена в видео https://www.youtube.com/watch?v=-I-9xpLnFnk.  
  Для того, чтобы подключить спринг нужны 2 зависимости: spring-core и spring-context.  
  
**Qualifier**  
Квалификатор аннотации позволяет устранить неоднозначность ссылок бина, когда сам Spring не сможет этого сделать. 


**Полезные ссылки, паттерны, инструменты и т.д.**  
**Про наследование в JPA. Как описывать entity классы и стратегии создания таблиц по этим классам.**  
https://habr.com/ru/articles/337488/

**Про патерн синглтон, немного о синхронизации, synchronized, volatile, про ленивый и eager синглтон, хорошо про то, как писать тесты**
   https://www.youtube.com/watch?v=61duchvKI6o

**Про REST API и 6 принципов**
[https://javarush.com/groups/posts/2486-obzor-rest-chastjh-1-chto-takoe-rest  ](https://habr.com/ru/articles/471772/)  

**Про Инструменты для запуска и разработки Java приложений, компиляция, выполнение на JVM**
https://javarush.com/groups/posts/2486-obzor-rest-chastjh-1-chto-takoe-rest  

**Случайные вопросы**  
1) Почему по умолчанию в спринге все бины не ленивый синглтон? - потому что лучше, чтоб все классы создались в bootstrap-e. Пусть сервер медленнее поднимается, но зато всё, что можно было создать создасться с самого начала (Fail fast)  
2) (минусы ленивого синглтона) Почему важно все чт оможно создавать всё с самого начала (Fail fast)? - Потому что проверили проект, всё вроде работает, задеплоили. Потом спустя время клиент вызвал какой то там бин, создался ленивый синглтон - и все сломалось. А для чего может понадобиться синглтон?  
3) Как реализован Lazy в Спринг? - Если проставить Lazy над классом, а потом его где нибудь заинжектить - бин все равно будет создаваться. Так как нам нужно же что то положить в поле, помеченным Autowired. (Раньше был спосооб, когда вместо класса инжектили весь контекст, а далее доставали нужный бин. В таком случае объект бы создавался в момент, когда бин вытаскивали из контекста). Далее, в спринге появилась возможность ставить @Lazy над полем или конструктором. Тогда вместо класса создасться Прокси класс, задача которого вытаскивать нужный нам класс в момент вызова. Красивое решение для ленивых синглтонов из коробки.  
